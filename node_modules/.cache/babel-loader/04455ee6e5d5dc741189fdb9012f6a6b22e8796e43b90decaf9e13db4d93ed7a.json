{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { createCanvas, env, getContext2dOrThrow, imageTensorToCanvas, toNetInput } from 'tfjs-image-recognition-base';\nimport { FaceDetection } from '../classes/FaceDetection';\n/**\r\n * Extracts the image regions containing the detected faces.\r\n *\r\n * @param input The image that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns The Canvases of the corresponding image region for each detected face.\r\n */\nexport function extractFaces(input, detections) {\n  return tslib_1.__awaiter(this, void 0, void 0, function () {\n    var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          Canvas = env.getEnv().Canvas;\n          canvas = input;\n          if (!!(input instanceof Canvas)) return [3 /*break*/, 5];\n          return [4 /*yield*/, toNetInput(input)];\n        case 1:\n          netInput = _b.sent();\n          if (netInput.batchSize > 1) {\n            throw new Error('extractFaces - batchSize > 1 not supported');\n          }\n          tensorOrCanvas = netInput.getInput(0);\n          if (!(tensorOrCanvas instanceof Canvas)) return [3 /*break*/, 2];\n          _a = tensorOrCanvas;\n          return [3 /*break*/, 4];\n        case 2:\n          return [4 /*yield*/, imageTensorToCanvas(tensorOrCanvas)];\n        case 3:\n          _a = _b.sent();\n          _b.label = 4;\n        case 4:\n          canvas = _a;\n          _b.label = 5;\n        case 5:\n          ctx = getContext2dOrThrow(canvas);\n          boxes = detections.map(function (det) {\n            return det instanceof FaceDetection ? det.forSize(canvas.width, canvas.height).box.floor() : det;\n          }).map(function (box) {\n            return box.clipAtImageBorders(canvas.width, canvas.height);\n          });\n          return [2 /*return*/, boxes.map(function (_a) {\n            var x = _a.x,\n              y = _a.y,\n              width = _a.width,\n              height = _a.height;\n            var faceImg = createCanvas({\n              width: width,\n              height: height\n            });\n            getContext2dOrThrow(faceImg).putImageData(ctx.getImageData(x, y, width, height), 0, 0);\n            return faceImg;\n          })];\n      }\n    });\n  });\n}","map":{"version":3,"names":["createCanvas","env","getContext2dOrThrow","imageTensorToCanvas","toNetInput","FaceDetection","extractFaces","input","detections","Canvas","getEnv","canvas","netInput","_b","sent","batchSize","Error","tensorOrCanvas","getInput","_a","ctx","boxes","map","det","forSize","width","height","box","floor","clipAtImageBorders","x","y","faceImg","putImageData","getImageData"],"sources":["C:\\Online Exam Proctoring System\\frontend\\node_modules\\face-api.js\\src\\dom\\extractFaces.ts"],"sourcesContent":["import {\r\n  createCanvas,\r\n  env,\r\n  getContext2dOrThrow,\r\n  imageTensorToCanvas,\r\n  Rect,\r\n  TNetInput,\r\n  toNetInput,\r\n} from 'tfjs-image-recognition-base';\r\n\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\n\r\n/**\r\n * Extracts the image regions containing the detected faces.\r\n *\r\n * @param input The image that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns The Canvases of the corresponding image region for each detected face.\r\n */\r\nexport async function extractFaces(\r\n  input: TNetInput,\r\n  detections: Array<FaceDetection | Rect>\r\n): Promise<HTMLCanvasElement[]> {\r\n\r\n  const { Canvas } = env.getEnv()\r\n\r\n  let canvas = input as HTMLCanvasElement\r\n\r\n  if (!(input instanceof Canvas)) {\r\n    const netInput = await toNetInput(input)\r\n\r\n    if (netInput.batchSize > 1) {\r\n      throw new Error('extractFaces - batchSize > 1 not supported')\r\n    }\r\n\r\n    const tensorOrCanvas = netInput.getInput(0)\r\n    canvas = tensorOrCanvas instanceof Canvas\r\n      ? tensorOrCanvas\r\n      : await imageTensorToCanvas(tensorOrCanvas)\r\n  }\r\n\r\n  const ctx = getContext2dOrThrow(canvas)\r\n  const boxes = detections.map(\r\n    det => det instanceof FaceDetection\r\n      ? det.forSize(canvas.width, canvas.height).box.floor()\r\n      : det\r\n  )\r\n    .map(box => box.clipAtImageBorders(canvas.width, canvas.height))\r\n\r\n  return boxes.map(({ x, y, width, height }) => {\r\n    const faceImg = createCanvas({ width, height })\r\n    getContext2dOrThrow(faceImg)\r\n      .putImageData(ctx.getImageData(x, y, width, height), 0, 0)\r\n    return faceImg\r\n  })\r\n}"],"mappings":";AAAA,SACEA,YAAY,EACZC,GAAG,EACHC,mBAAmB,EACnBC,mBAAmB,EAGnBC,UAAU,QACL,6BAA6B;AAEpC,SAASC,aAAa,QAAQ,0BAA0B;AAExD;;;;;;;AAOA,OAAM,SAAgBC,YAAYA,CAChCC,KAAgB,EAChBC,UAAuC;;;;;;UAG/BC,MAAM,GAAKR,GAAG,CAACS,MAAM,EAAE,CAAAD,MAAjB;UAEVE,MAAM,GAAGJ,KAA0B;eAEnC,EAAEA,KAAK,YAAYE,MAAM,CAAC,EAA1B;UACe,qBAAML,UAAU,CAACG,KAAK,CAAC;;UAAlCK,QAAQ,GAAGC,EAAA,CAAAC,IAAA,EAAuB;UAExC,IAAIF,QAAQ,CAACG,SAAS,GAAG,CAAC,EAAE;YAC1B,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;;UAGzDC,cAAc,GAAGL,QAAQ,CAACM,QAAQ,CAAC,CAAC,CAAC;gBAClCD,cAAc,YAAYR,MAAM,GAAhC;UACLU,EAAA,GAAAF,cAAc;;;UACd,qBAAMd,mBAAmB,CAACc,cAAc,CAAC;;UAAzCE,EAAA,GAAAN,EAAA,CAAAC,IAAA,EAAyC;;;UAF7CH,MAAM,GAAAQ,EAEuC;;;UAGzCC,GAAG,GAAGlB,mBAAmB,CAACS,MAAM,CAAC;UACjCU,KAAK,GAAGb,UAAU,CAACc,GAAG,CAC1B,UAAAC,GAAG;YAAI,OAAAA,GAAG,YAAYlB,aAAa,GAC/BkB,GAAG,CAACC,OAAO,CAACb,MAAM,CAACc,KAAK,EAAEd,MAAM,CAACe,MAAM,CAAC,CAACC,GAAG,CAACC,KAAK,EAAE,GACpDL,GAAG;UAFA,CAEA,CACR,CACED,GAAG,CAAC,UAAAK,GAAG;YAAI,OAAAA,GAAG,CAACE,kBAAkB,CAAClB,MAAM,CAACc,KAAK,EAAEd,MAAM,CAACe,MAAM,CAAC;UAAnD,CAAmD,CAAC;UAElE,sBAAOL,KAAK,CAACC,GAAG,CAAC,UAACH,EAAuB;gBAArBW,CAAA,GAAAX,EAAA,CAAAW,CAAC;cAAEC,CAAA,GAAAZ,EAAA,CAAAY,CAAC;cAAEN,KAAA,GAAAN,EAAA,CAAAM,KAAK;cAAEC,MAAA,GAAAP,EAAA,CAAAO,MAAM;YACrC,IAAMM,OAAO,GAAGhC,YAAY,CAAC;cAAEyB,KAAK,EAAAA,KAAA;cAAEC,MAAM,EAAAA;YAAA,CAAE,CAAC;YAC/CxB,mBAAmB,CAAC8B,OAAO,CAAC,CACzBC,YAAY,CAACb,GAAG,CAACc,YAAY,CAACJ,CAAC,EAAEC,CAAC,EAAEN,KAAK,EAAEC,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAC5D,OAAOM,OAAO;UAChB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}